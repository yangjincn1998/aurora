import os
import pysrt
import logging


# --- Logging Configuration (if this file runs as a standalone module, configure separately) ---
# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s %(module)s %(levelname)s: %(message)s',
#     encoding='utf-8'
# )

def bilingual_to_file(
        jap_srt_path: str,
        sch_srt_path: str,
        output_ass_path: str,
        output_srt_path: str,
        metadata_srt_header: str = "",  # New parameter: SRT header metadata
        metadata_ass_dialogue: str = ""  # New parameter: ASS dialogue metadata
) -> bool:
    """
    Combines Japanese and Chinese SRT subtitles into bilingual SRT and ASS files,
    with optional metadata headers embedded.

    Args:
        jap_srt_path (str): Path to the Japanese SRT subtitle file.
        sch_srt_path (str): Path to the Chinese SRT subtitle file.
        output_ass_path (str): Path to the output ASS bilingual subtitle file.
        output_srt_path (str): Path to the output SRT bilingual subtitle file.
        metadata_srt_header (str): Metadata string to embed at the beginning of the SRT file.
        metadata_ass_dialogue (str): Metadata dialogue line string to embed at the beginning
                                     of the [Events] section in the ASS file.

    Returns:
        bool: True if merging was successful.
    """
    logging.info(
        f"Starting to merge Japanese '{os.path.basename(jap_srt_path)}' and Chinese '{os.path.basename(sch_srt_path)}' subtitles.")

    try:
        subs_jap = pysrt.open(jap_srt_path, encoding='utf-8')
        subs_sch = pysrt.open(sch_srt_path, encoding='utf-8')
    except Exception as e:
        logging.error(f"Failed to load SRT files: {e}", exc_info=True)
        return False

    # --- Generate Bilingual SRT ---
    merged_srt_content = ""
    if metadata_srt_header:
        merged_srt_content += metadata_srt_header + "\n"  # Embed metadata header

    # Ensure both subtitle files have the same number of entries, or at least handle them
    # Assuming they are synchronized by index here
    max_len = max(len(subs_jap), len(subs_sch))
    for i in range(max_len):
        jap_text = subs_jap[i].text if i < len(subs_jap) else ""
        sch_text = subs_sch[i].text if i < len(subs_sch) else ""

        # Use the timestamp of the first subtitle, as Japanese subtitles are usually more complete
        start_time = subs_jap[i].start if i < len(subs_jap) else (subs_sch[i].start if i < len(subs_sch) else None)
        end_time = subs_jap[i].end if i < len(subs_jap) else (subs_sch[i].end if i < len(subs_sch) else None)

        if start_time is None or end_time is None:
            logging.warning(f"Skipping subtitle entry {i + 1}: Missing timestamp information.")
            continue

        # Format timestamp
        start_str = _format_pysrt_time(start_time)
        end_str = _format_pysrt_time(end_time)

        # Build bilingual text
        bilingual_text = f"{jap_text}\n{sch_text}".strip()  # strip() removes extra blank lines

        if bilingual_text:  # Only add entry if there is actual content
            merged_srt_content += f"{i + 1}\n"
            merged_srt_content += f"{start_str} --> {end_str}\n"
            merged_srt_content += f"{bilingual_text}\n\n"

    try:
        with open(output_srt_path, 'w', encoding='utf-8') as f:
            f.write(merged_srt_content.strip())  # Write and remove trailing extra newlines
        logging.info(f"Bilingual SRT file saved to: {output_srt_path}")
    except Exception as e:
        logging.error(f"Failed to save bilingual SRT file: {e}", exc_info=True)
        return False

    # --- Generate Bilingual ASS ---
    # ASS Header Template
    ass_header = """[Script Info]
; Script generated by AURORA Subtitle Tool
Title: Merged Subtitle
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,24,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Metadata,Arial,20,&H00FFFF00,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,7,10,10,10,1
[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
"""

    merged_ass_content = ass_header
    if metadata_ass_dialogue:
        merged_ass_content += metadata_ass_dialogue + "\n"  # Embed metadata dialogue line

    for i in range(max_len):
        jap_text = subs_jap[i].text if i < len(subs_jap) else ""
        sch_text = subs_sch[i].text if i < len(subs_sch) else ""

        start_time = subs_jap[i].start if i < len(subs_jap) else (subs_sch[i].start if i < len(subs_sch) else None)
        end_time = subs_jap[i].end if i < len(subs_jap) else (subs_sch[i].end if i < len(subs_sch) else None)

        if start_time is None or end_time is None:
            continue

        # Format timestamp for ASS format (H:MM:SS.cc)
        start_str_ass = _format_pysrt_time_ass(start_time)
        end_str_ass = _format_pysrt_time_ass(end_time)

        # Build bilingual text, \N or \n usually for newlines in ASS
        # Ensure ASS special characters like {} are escaped
        cleaned_jap_text = jap_text.replace('{', '\\{').replace('}', '\\}').replace('\n', '\\N')
        cleaned_sch_text = sch_text.replace('{', '\\{').replace('}', '\\}').replace('\n', '\\N')

        if cleaned_jap_text and cleaned_sch_text:
            bilingual_ass_text = f"{cleaned_jap_text}\\N{cleaned_sch_text}"
        elif cleaned_jap_text:
            bilingual_ass_text = cleaned_jap_text
        elif cleaned_sch_text:
            bilingual_ass_text = cleaned_sch_text
        else:
            continue  # Skip if no content

        # ASS Dialogue line format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
        merged_ass_content += f"Dialogue: 0,{start_str_ass},{end_str_ass},Default,,0,0,0,,{bilingual_ass_text}\n"

    try:
        with open(output_ass_path, 'w', encoding='utf-8') as f:
            f.write(merged_ass_content.strip())
        logging.info(f"Bilingual ASS file saved to: {output_ass_path}")
        return True
    except Exception as e:
        logging.error(f"Failed to save bilingual ASS file: {e}", exc_info=True)
        return False


def _format_pysrt_time(time_obj: pysrt.SubRipTime) -> str:
    """
    Formats a pysrt.SubRipTime object into SRT timestamp format (HH:MM:SS,mmm).
    """
    return f"{time_obj.hours:02d}:{time_obj.minutes:02d}:{time_obj.seconds:02d},{time_obj.milliseconds:03d}"


def _format_pysrt_time_ass(time_obj: pysrt.SubRipTime) -> str:
    """
    Formats a pysrt.SubRipTime object into ASS timestamp format (H:MM:SS.cc).
    """
    # ASS timestamps are in 10-millisecond units (centiseconds)
    total_milliseconds = time_obj.hours * 3_600_000 + time_obj.minutes * 60_000 + time_obj.seconds * 1_000 + time_obj.milliseconds
    centiseconds = total_milliseconds // 10

    hours = centiseconds // 360000
    centiseconds %= 360000
    minutes = centiseconds // 6000
    centiseconds %= 6000
    seconds = centiseconds // 100
    centiseconds %= 100

    return f"{hours}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}"


# --- Example Usage (if this file runs as a standalone module) ---
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(module)s %(levelname)s: %(message)s',
                        encoding='utf-8')

    # Create dummy SRT files for testing
    test_jap_srt_path = "test_jap.srt"
    test_sch_srt_path = "test_sch.srt"
    test_output_ass_path = "test_output.ass"
    test_output_srt_path = "test_output.srt"

    jap_content = """1
00:00:01,000 --> 00:00:03,000
こんにちは

2
00:00:04,000 --> 00:00:06,000
これはテストです
"""
    sch_content = """1
00:00:01,000 --> 00:00:03,000
你好

2
00:00:04,000 --> 00:00:06,000
这是一个测试
"""

    with open(test_jap_srt_path, "w", encoding="utf-8") as f:
        f.write(jap_content)
    with open(test_sch_srt_path, "w", encoding="utf-8") as f:
        f.write(sch_content)

    print("--- Testing Bilingual Merge ---")

    # Example metadata
    sample_srt_header = """1
00:00:00,000 --> 00:00:05,000
影片标题: 测试影片
发行日期: 2023-01-01
演员: 某某某
导演: 某导演
类别: 某类型
"""
    sample_ass_dialogue = r"Dialogue: 0,0:00:00.00,0:00:05.00,Metadata,,0,0,0,,{\an7}影片标题: 测试影片\N发行日期: 2023-01-01\N演员: 某某某\N导演: 某导演\N类别: 某类型"

    if bilingual_to_file(
            test_jap_srt_path,
            test_sch_srt_path,
            test_output_ass_path,
            test_output_srt_path,
            metadata_srt_header=sample_srt_header,
            metadata_ass_dialogue=sample_ass_dialogue
    ):
        print(f"Bilingual subtitle files successfully generated: {test_output_ass_path}, {test_output_srt_path}")
        # Print SRT content
        print("\n--- Generated SRT Content ---")
        with open(test_output_srt_path, 'r', encoding='utf-8') as f:
            print(f.read())
        # Print ASS content
        print("\n--- Generated ASS Content ---")
        with open(test_output_ass_path, 'r', encoding='utf-8') as f:
            print(f.read())
    else:
        print("Bilingual subtitle file generation failed.")

    # Clean up test files
    if os.path.exists(test_jap_srt_path): os.remove(test_jap_srt_path)
    if os.path.exists(test_sch_srt_path): os.remove(test_sch_srt_path)
    if os.path.exists(test_output_ass_path): os.remove(test_output_ass_path)
    if os.path.exists(test_output_srt_path): os.remove(test_output_srt_path)
    print("\nTest cleanup completed.")
